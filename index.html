<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>OG Galaxy - Open Graph Image Explorer</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Schibsted+Grotesk:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --bg: #f5f5f2;
      --surface: #ffffff;
      --surface-muted: #fafaf8;
      --border: #dcdcd4;
      --border-strong: #c6c6bc;
      --text: #171717;
      --text-muted: #5f5f58;
      --accent: #111111;
      --accent-contrast: #ffffff;
      --success: #1f7a50;
      --warning: #946700;
      --info: #0d4e81;
      --danger: #8f2f2f;
      --radius: 12px;
      --radius-sm: 10px;
    }

    body {
      font-family: "Schibsted Grotesk", ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      padding: 2.5rem 1rem 4rem;
      line-height: 1.5;
      -webkit-font-smoothing: antialiased;
      color-scheme: light;
    }

    .container {
      max-width: 1120px;
      margin: 0 auto;
    }

    h1 {
      font-size: clamp(2rem, 4vw, 2.7rem);
      margin-bottom: 0.4rem;
      letter-spacing: -0.02em;
      font-weight: 600;
    }

    .subtitle {
      color: var(--text-muted);
      margin-bottom: 1.8rem;
      font-size: 0.98rem;
    }

    .input-section {
      margin-bottom: 2rem;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 1rem;
    }

    .input-wrapper {
      display: flex;
      gap: 0.7rem;
    }

    input {
      flex: 1;
      padding: 0.82rem 0.95rem;
      border: 1px solid var(--border);
      background: var(--surface);
      color: var(--text);
      border-radius: var(--radius-sm);
      font-size: 1rem;
      outline: none;
      transition: border-color 0.2s, box-shadow 0.2s;
    }

    input:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(17, 17, 17, 0.1);
    }

    input::placeholder {
      color: #8f8f87;
    }

    button {
      padding: 0.82rem 1.4rem;
      background: var(--accent);
      color: var(--accent-contrast);
      border: 1px solid var(--accent);
      border-radius: var(--radius-sm);
      font-size: 0.96rem;
      font-weight: 600;
      cursor: pointer;
      transition: background-color 0.2s, border-color 0.2s, opacity 0.2s;
    }

    button:hover:not(:disabled) {
      background: #2a2a2a;
      border-color: #2a2a2a;
    }

    button:focus-visible {
      outline: 3px solid rgba(17, 17, 17, 0.15);
      outline-offset: 1px;
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(170px, 1fr));
      gap: 0.9rem;
      margin-bottom: 2rem;
    }

    .stat {
      padding: 0.9rem 1rem;
      background: var(--surface);
      border-radius: var(--radius-sm);
      border: 1px solid var(--border);
    }

    .stat-label {
      font-size: 0.74rem;
      color: var(--text-muted);
      margin-bottom: 0.2rem;
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }

    .stat-value {
      font-size: 1.45rem;
      font-weight: 600;
      color: var(--text);
    }

    .stat.success .stat-value {
      color: var(--success);
    }

    .stat.warning .stat-value {
      color: var(--warning);
    }

    .stat.info .stat-value {
      color: var(--info);
    }

    .status {
      padding: 0.85rem 0.95rem;
      border-radius: var(--radius-sm);
      margin-top: 0.6rem;
      border: 1px solid;
      font-size: 0.95rem;
    }

    .status.loading {
      background: #f1f5fa;
      border-color: #d8e2ed;
      color: #2a5276;
    }

    .status.error {
      background: #fff3f3;
      border-color: #efd3d3;
      color: var(--danger);
    }

    .section {
      margin-top: 2.2rem;
    }

    .section-header {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-bottom: 1rem;
    }

    .section-action-btn {
      margin-left: auto;
      padding: 0.48rem 0.95rem;
      font-size: 0.875rem;
      background: var(--surface);
      color: var(--text);
      border-color: var(--border);
    }

    .section-action-btn:hover:not(:disabled) {
      background: var(--surface-muted);
      border-color: var(--border-strong);
    }

    .section-title {
      font-size: 1.15rem;
      font-weight: 600;
      color: var(--text);
    }

    .section-count {
      padding: 0.25rem 0.7rem;
      border-radius: 999px;
      font-size: 0.82rem;
      font-weight: 600;
      background: #ededea;
      color: var(--text);
    }

    .section-count.success {
      background: #e6f4ec;
      color: var(--success);
    }

    .section-count.warning {
      background: #f8f1e2;
      color: var(--warning);
    }

    .section-count.info {
      background: #e6f0f8;
      color: var(--info);
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: 1rem;
    }

    .card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      overflow: hidden;
      transition: border-color 0.2s, box-shadow 0.2s;
    }

    .card:hover {
      border-color: var(--border-strong);
      box-shadow: 0 8px 18px rgba(17, 17, 17, 0.07);
    }

    .card-image {
      width: 100%;
      aspect-ratio: 1.91 / 1;
      object-fit: cover;
      background: linear-gradient(90deg, #ecece7 0%, #f6f6f3 50%, #ecece7 100%);
      background-size: 200% 100%;
      animation: shimmer 1.5s infinite;
    }

    .card-image.loaded {
      animation: none;
    }

    @keyframes shimmer {
      0% { background-position: 200% 0; }
      100% { background-position: -200% 0; }
    }

    .card-content {
      padding: 0.9rem;
    }

    .card-title {
      font-size: 0.84rem;
      color: var(--text-muted);
      word-break: break-all;
      line-height: 1.4;
    }

    .card-title a {
      color: var(--text);
      text-decoration: none;
    }

    .card-title a:hover {
      text-decoration: underline;
    }

    .loader {
      display: inline-block;
      width: 14px;
      height: 14px;
      border: 2px solid #d2d2cb;
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
      margin-left: 0.5rem;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .url-list {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .url-item {
      padding: 0.875rem 1rem;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      display: flex;
      align-items: center;
      gap: 0.75rem;
      transition: border-color 0.2s, background-color 0.2s;
    }

    .url-item:hover {
      border-color: var(--border-strong);
      background: var(--surface-muted);
    }

    .url-item-icon {
      width: 20px;
      height: 20px;
      flex-shrink: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      opacity: 0.75;
    }

    .url-item-link {
      flex: 1;
      color: var(--text-muted);
      text-decoration: none;
      font-size: 0.875rem;
      word-break: break-all;
      line-height: 1.4;
    }

    .url-item-link:hover {
      color: var(--text);
    }

    .collapsible {
      max-height: 360px;
      overflow-y: auto;
      padding-right: 0.5rem;
    }

    .collapsible::-webkit-scrollbar {
      width: 8px;
    }

    .collapsible::-webkit-scrollbar-track {
      background: #efefea;
      border-radius: 4px;
    }

    .collapsible::-webkit-scrollbar-thumb {
      background: #c8c8bf;
      border-radius: 4px;
    }

    .collapsible::-webkit-scrollbar-thumb:hover {
      background: #b2b2a8;
    }

    .expand-btn {
      margin-top: 1rem;
      padding: 0.5rem 1rem;
      background: transparent;
      border: 1px solid var(--border);
      color: var(--text-muted);
      border-radius: 6px;
      font-size: 0.875rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .expand-btn:hover {
      border-color: var(--border-strong);
      color: var(--text);
      background: var(--surface-muted);
    }

    .hidden {
      display: none;
    }

    @media (max-width: 640px) {
      body {
        padding-top: 1.5rem;
      }

      h1 {
        font-size: 1.9rem;
      }

      .subtitle {
        margin-bottom: 1.2rem;
      }

      .input-section {
        padding: 0.8rem;
      }

      .input-wrapper {
        flex-direction: column;
      }

      .grid {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>OG Galaxy</h1>
    <p class="subtitle">Explore Open Graph images across any website</p>

    <div class="input-section">
      <div class="input-wrapper">
        <input 
          type="text" 
          id="domainInput" 
          placeholder="Enter domain (e.g., example.com)"
          autocomplete="off"
        >
        <button id="fetchBtn" onclick="fetchOgImages()">Explore</button>
      </div>
      
      <div id="status" class="hidden"></div>
    </div>

    <div id="stats" class="stats hidden"></div>
    
    <div id="withImagesSection" class="section hidden">
      <div class="section-header">
        <h2 class="section-title">Pages with OG Images</h2>
        <span id="withImagesCount" class="section-count success">0</span>
      </div>
      <div id="withImagesGrid" class="grid"></div>
    </div>

    <div id="withoutImagesSection" class="section hidden">
      <div class="section-header">
        <h2 class="section-title">Pages without OG Images</h2>
        <span id="withoutImagesCount" class="section-count warning">0</span>
      </div>
      <div id="withoutImagesList" class="url-list collapsible"></div>
    </div>

    <div id="unprocessedSection" class="section hidden">
      <div class="section-header">
        <h2 class="section-title">Unprocessed Pages</h2>
        <span id="unprocessedCount" class="section-count info">0</span>
        <button id="processUnprocessedBtn" class="section-action-btn hidden" onclick="processUnprocessedPages()">Process Unprocessed</button>
      </div>
      <div id="unprocessedList" class="url-list collapsible"></div>
    </div>
  </div>

  <script>
    const domainInput = document.getElementById('domainInput');
    const fetchBtn = document.getElementById('fetchBtn');
    const statusDiv = document.getElementById('status');
    const statsDiv = document.getElementById('stats');
    
    // Section elements
    const withImagesSection = document.getElementById('withImagesSection');
    const withImagesCount = document.getElementById('withImagesCount');
    const withImagesGrid = document.getElementById('withImagesGrid');
    
    const withoutImagesSection = document.getElementById('withoutImagesSection');
    const withoutImagesCount = document.getElementById('withoutImagesCount');
    const withoutImagesList = document.getElementById('withoutImagesList');
    
    const unprocessedSection = document.getElementById('unprocessedSection');
    const unprocessedCount = document.getElementById('unprocessedCount');
    const unprocessedList = document.getElementById('unprocessedList');
    const processUnprocessedBtn = document.getElementById('processUnprocessedBtn');

    const UNPROCESSED_BATCH_LIMIT = 50;
    let pagesWithImagesState = [];
    let pagesWithoutImagesState = [];
    let unprocessedPagesState = [];

    domainInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        fetchOgImages();
      }
    });

    function showStatus(message, type = 'loading') {
      statusDiv.className = `status ${type}`;
      statusDiv.textContent = message;
      statusDiv.classList.remove('hidden');
    }

    function hideStatus() {
      statusDiv.classList.add('hidden');
    }

    function showStats(data) {
      statsDiv.innerHTML = `
        <div class="stat success">
          <div class="stat-label">OG Images Found</div>
          <div class="stat-value">${data.found}</div>
        </div>
        <div class="stat warning">
          <div class="stat-label">Not Found</div>
          <div class="stat-value">${data.notFound}</div>
        </div>
        <div class="stat info">
          <div class="stat-label">Unprocessed</div>
          <div class="stat-value">${data.unprocessed}</div>
        </div>
        <div class="stat">
          <div class="stat-label">Total URLs</div>
          <div class="stat-value">${data.total}</div>
        </div>
      `;
      statsDiv.classList.remove('hidden');
    }

    function createUrlItem(url, icon = 'ðŸ“„') {
      const item = document.createElement('div');
      item.className = 'url-item';
      
      const iconSpan = document.createElement('span');
      iconSpan.className = 'url-item-icon';
      iconSpan.textContent = icon;
      
      const link = document.createElement('a');
      link.className = 'url-item-link';
      link.href = url;
      link.target = '_blank';
      link.rel = 'noopener';
      link.textContent = url;
      
      item.appendChild(iconSpan);
      item.appendChild(link);
      return item;
    }

    function createImageCard(page) {
      const card = document.createElement('div');
      card.className = 'card';

      const img = document.createElement('img');
      img.src = page.ogImage;
      img.alt = 'OG Image';
      img.className = 'card-image';
      img.onload = () => img.classList.add('loaded');
      img.onerror = () => {
        img.src = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='400' height='210'%3E%3Crect fill='%23f1f1ec' width='400' height='210'/%3E%3Ctext fill='%23686860' x='50%25' y='50%25' text-anchor='middle' dy='.3em' font-family='sans-serif' font-size='14'%3EImage unavailable%3C/text%3E%3C/svg%3E";
        img.classList.add('loaded');
      };

      const content = document.createElement('div');
      content.className = 'card-content';
      content.innerHTML = `
        <div class="card-title">
          <a href="${page.url}" target="_blank" rel="noopener">${page.url}</a>
        </div>
      `;

      card.appendChild(img);
      card.appendChild(content);
      return card;
    }

    function resetSections() {
      statsDiv.classList.add('hidden');
      withImagesSection.classList.add('hidden');
      withoutImagesSection.classList.add('hidden');
      unprocessedSection.classList.add('hidden');
      withImagesGrid.innerHTML = '';
      withoutImagesList.innerHTML = '';
      unprocessedList.innerHTML = '';
      withImagesCount.textContent = '0';
      withoutImagesCount.textContent = '0';
      unprocessedCount.textContent = '0';
      processUnprocessedBtn.classList.add('hidden');
      processUnprocessedBtn.disabled = false;
    }

    function showStatsFromState() {
      const found = pagesWithImagesState.length;
      const notFound = pagesWithoutImagesState.length;
      const unprocessed = unprocessedPagesState.length;

      showStats({
        found,
        notFound,
        unprocessed,
        total: found + notFound + unprocessed
      });
    }

    function getUniquePages(existingPages, incomingPages) {
      const existingUrls = new Set(existingPages.map(page => page.url));
      return incomingPages.filter(page => {
        if (!page || !page.url || existingUrls.has(page.url)) {
          return false;
        }

        existingUrls.add(page.url);
        return true;
      });
    }

    function appendPagesWithImages(pages) {
      if (!pages || pages.length === 0) {
        return;
      }

      withImagesSection.classList.remove('hidden');
      pages.forEach(page => {
        withImagesGrid.appendChild(createImageCard(page));
      });

      withImagesCount.textContent = pagesWithImagesState.length;
    }

    function appendPagesWithoutImages(pages) {
      if (!pages || pages.length === 0) {
        return;
      }

      withoutImagesSection.classList.remove('hidden');
      pages.forEach(page => {
        withoutImagesList.appendChild(createUrlItem(page.url, 'âš ï¸'));
      });

      withoutImagesCount.textContent = pagesWithoutImagesState.length;
    }

    function renderUnprocessedPages() {
      unprocessedList.innerHTML = '';

      if (unprocessedPagesState.length === 0) {
        unprocessedSection.classList.add('hidden');
        processUnprocessedBtn.classList.add('hidden');
        unprocessedCount.textContent = '0';
        return;
      }

      unprocessedSection.classList.remove('hidden');
      processUnprocessedBtn.classList.remove('hidden');
      unprocessedCount.textContent = unprocessedPagesState.length;

      unprocessedPagesState.forEach(url => {
        unprocessedList.appendChild(createUrlItem(url, 'â¸ï¸'));
      });
    }

    async function processUnprocessedPages() {
      if (unprocessedPagesState.length === 0) {
        return;
      }

      const processCount = Math.min(UNPROCESSED_BATCH_LIMIT, unprocessedPagesState.length);
      processUnprocessedBtn.disabled = true;
      fetchBtn.disabled = true;
      showStatus(`Processing ${processCount} unprocessed pages...`);

      try {
        const response = await fetch('/api/process-unprocessed', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            urls: unprocessedPagesState,
            limit: UNPROCESSED_BATCH_LIMIT
          })
        });

        const data = await response.json();

        if (!response.ok) {
          throw new Error(data.error || 'Failed to process unprocessed pages');
        }

        const uniqueWithImages = getUniquePages(pagesWithImagesState, data.pagesWithImages || []);
        const uniqueWithoutImages = getUniquePages(pagesWithoutImagesState, data.pagesWithoutImages || []);

        pagesWithImagesState.push(...uniqueWithImages);
        pagesWithoutImagesState.push(...uniqueWithoutImages);
        unprocessedPagesState = Array.isArray(data.unprocessedPages)
          ? data.unprocessedPages.filter(url => typeof url === 'string' && url.trim())
          : [];

        appendPagesWithImages(uniqueWithImages);
        appendPagesWithoutImages(uniqueWithoutImages);
        renderUnprocessedPages();
        showStatsFromState();
        hideStatus();
      } catch (error) {
        showStatus(error.message, 'error');
      } finally {
        processUnprocessedBtn.disabled = false;
        fetchBtn.disabled = false;
      }
    }

    async function fetchOgImages() {
      const domain = domainInput.value.trim();
      
      if (!domain) {
        showStatus('Please enter a domain', 'error');
        return;
      }

      fetchBtn.disabled = true;
      
      pagesWithImagesState = [];
      pagesWithoutImagesState = [];
      unprocessedPagesState = [];
      resetSections();
      
      showStatus('Fetching sitemap and analyzing pages...');

      try {
        const response = await fetch('/api/fetch-og-images', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ domain })
        });

        const data = await response.json();

        if (!response.ok) {
          throw new Error(data.error || 'Failed to fetch OG images');
        }

        pagesWithImagesState = getUniquePages([], data.pagesWithImages || []);
        pagesWithoutImagesState = getUniquePages([], data.pagesWithoutImages || []);
        unprocessedPagesState = Array.isArray(data.unprocessedPages)
          ? data.unprocessedPages.filter(url => typeof url === 'string' && url.trim())
          : [];

        showStatsFromState();
        appendPagesWithImages(pagesWithImagesState);
        appendPagesWithoutImages(pagesWithoutImagesState);
        renderUnprocessedPages();
        hideStatus();

        // Show message if nothing found at all
        if (data.total === 0) {
          showStatus('No URLs found in sitemap', 'error');
        }

      } catch (error) {
        showStatus(error.message, 'error');
        statsDiv.classList.add('hidden');
      } finally {
        fetchBtn.disabled = false;
      }
    }
  </script>
</body>
</html>
